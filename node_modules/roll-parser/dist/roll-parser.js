(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.rollParser = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/* eslint global-require: "off" */
module.exports = {
  Roll: require( './src/object/Roll' ),
  WodRoll: require( './src/object/WodRoll' ),
  Result: require( './src/object/Result' ),

  parse: require( './src/complex/parse' ),
  parseClassicRoll: require( './src/complex/parseClassicRoll' ),
  parseSimpleRoll: require( './src/complex/parseSimpleRoll' ),
  parseWodRoll: require( './src/complex/parseWodRoll' ),

  roll: require( './src/roller' ).rollAny,
  rollClassic: require( './src/roller' ).rollClassic,
  rollWod: require( './src/roller' ).rollWod,

  parseAndRoll: require( './src/complex/parseAndRoll' ),
  parseAndRollSimple: require( './src/complex/parseAndRollSimple' ),
  parseAndRollClassic: require( './src/complex/parseAndRollClassic' ),
  parseAndRollWod: require( './src/complex/parseAndRollWod' ),

  random: require( './src/random' ).randomRoll,

  convert: require( './src/converter' ).convertToAnyRoll,
};

},{"./src/complex/parse":2,"./src/complex/parseAndRoll":3,"./src/complex/parseAndRollClassic":4,"./src/complex/parseAndRollSimple":5,"./src/complex/parseAndRollWod":6,"./src/complex/parseClassicRoll":7,"./src/complex/parseSimpleRoll":8,"./src/complex/parseWodRoll":9,"./src/converter":10,"./src/object/Result":14,"./src/object/Roll":15,"./src/object/WodRoll":17,"./src/random":19,"./src/roller":20}],2:[function(require,module,exports){
const { parseAny } = require( '../parser' );
const { mapToRoll, mapToWodRoll } = require( '../mapper' );
const Type = require( '../object/Type' );

/**
 * Parses simplified, classic or WoD roll notation.
 *
 * @func
 * @since v2.0.0
 * @param {String} roll
 * @return {Roll|WodRoll|null}
 * @see parseSimpleRoll
 * @see parseClassicRoll
 * @see parseWodRoll
 * @example
 * parse('2 10 -1');   //=> { dice: 10, count: 2, modifier: -1 }
 * parse('2d10+1');    //=> { dice: 10, count: 2, modifier: 1 }
 * parse('4d10!>8f1'); //=> { dice: 10, count: 4, again: true, success: 8, fail: 1 }
 * parse('xyz');       //=> null
 */
function parse( roll ) {
  const result = parseAny( roll );
  const type = result ? result.type : '';

  switch ( type ) {
    case Type.simple:
      return mapToRoll( result );
    case Type.classic:
      return mapToRoll( result );
    case Type.wod:
      return mapToWodRoll( result );
    default:
      return null;
  }
}

module.exports = parse;

},{"../mapper":12,"../object/Type":16,"../parser":18}],3:[function(require,module,exports){
const { rollAny } = require( '../roller' );
const parse = require( './parse' );

/**
 * Parses simplified, classic or WoD roll notation and then rolls the dice.
 *
 * @func
 * @since v2.0.0
 * @param {String} roll
 * @return {Result|null} Returns `Result` for defined parameters, otherwise returns `null`.
 * @see parseAndRollSimple
 * @see parseAndRollClassic
 * @see parseAndRollWod
 * @example
 * parseAndRoll('2 10 -1');   //=> { notation: '2d10-1', value: 14, rolls: [ 7, 8 ] }
 * parseAndRoll('2d10+1');    //=> { notation: '2d10+1', value: 9, rolls: [ 2, 6 ] }
 * parseAndRoll('4d10!>8f1'); //=> { notation: '4d10!>8f1', value: 2, rolls: [ 3, 10, 7, 9, 5 ] }
 */
const parseAndRoll = roll => rollAny( parse( roll ));

module.exports = parseAndRoll;

},{"../roller":20,"./parse":2}],4:[function(require,module,exports){
const { rollClassic } = require( '../roller' );
const parseClassicRoll = require( './parseClassicRoll' );

/**
 * Parses classic notation and then rolls the dice.
 *
 * @func
 * @since v2.0.0
 * @param {String} roll
 * @return {Result}
 * @see parseAndRoll
 * @see parseAndRollSimple
 * @see parseAndRollWod
 * @example
 * parseAndRollClassic('2d10+1');  //=> { notation: '2d10+1', value: 9, rolls: [ 2, 6 ] }
 * parseAndRollClassic('d6');      //=> { notation: 'd6', value: 3, rolls: [ 3 ] }
 */
const parseAndRollClassic = roll => rollClassic( parseClassicRoll( roll ));

module.exports = parseAndRollClassic;

},{"../roller":20,"./parseClassicRoll":7}],5:[function(require,module,exports){
const { rollClassic } = require( '../roller' );
const parseSimpleRoll = require( './parseSimpleRoll' );

/**
 * Parses simple notation and then rolls the dice.
 *
 * @func
 * @since v2.0.0
 * @param {String} roll
 * @return {Result}
 * @see parseAndRoll
 * @see parseAndRollSimple
 * @see parseAndRollWod
 * @example
 * parseAndRollSimple('2 10 -1'); //=> { notation: '2d10-1', value: 14, rolls: [ 7, 8 ] }
 */
const parseAndRollSimple = roll => rollClassic( parseSimpleRoll( roll ));

module.exports = parseAndRollSimple;

},{"../roller":20,"./parseSimpleRoll":8}],6:[function(require,module,exports){
const { rollWod } = require( '../roller' );
const parseWodRoll = require( './parseWodRoll' );

/**
 * Parses WoD roll notation and then rolls the dice.
 *
 * @func
 * @since v2.0.0
 * @param {String} roll
 * @return {Result}
 * @see parseAndRoll
 * @see parseAndRollSimple
 * @see parseAndRollClassic
 * @example
 * parseAndRollWod('2d10>6');    //=> { notation: '2d10>6', value: 1, rolls: [ 5, 10 ] }
 * parseAndRollWod('4d10!>8f1'); //=> { notation: '4d10!>8f1', value: 2, rolls: [ 3, 10, 7, 9, 5 ] }
 */
const parseAndRollWod = roll => rollWod( parseWodRoll( roll ));

module.exports = parseAndRollWod;

},{"../roller":20,"./parseWodRoll":9}],7:[function(require,module,exports){
const { parseClassic } = require( '../parser' );
const { mapToRoll } = require( '../mapper' );

/**
 * Parses classic DnD roll notation.
 *
 * @func
 * @since v2.0.0
 * @param {String} roll
 * @return {Roll}
 * @see parse
 * @see parseSimpleRoll
 * @see parseWodRoll
 * @example
 * parseClassicRoll('d10');    //=> { dice: 10, count: 1, modifier: 0 }
 * parseClassicRoll('2d10');   //=> { dice: 10, count: 2, modifier: 0 }
 * parseClassicRoll('d10+1');  //=> { dice: 10, count: 1, modifier: 1 }
 * parseClassicRoll('2d10-1'); //=> { dice: 10, count: 2, modifier: -1 }
 */
const parseClassicRoll = roll => mapToRoll( parseClassic( roll ));

module.exports = parseClassicRoll;

},{"../mapper":12,"../parser":18}],8:[function(require,module,exports){
const { parseSimple } = require( '../parser' );
const { mapToRoll } = require( '../mapper' );

/**
 * Parses simple roll notation (space separated values).
 *
 * @func
 * @since v2.0.0
 * @param {String} roll
 * @return {Roll}
 * @see parse
 * @see parseClassicRoll
 * @see parseWodRoll
 * @example
 * parseSimpleRoll('10');      //=> { dice: 10, count: 1, modifier: 0 }
 * parseSimpleRoll('2 10');    //=> { dice: 10, count: 2, modifier: 0 }
 * parseSimpleRoll('2 10 -1'); //=> { dice: 10, count: 2, modifier: -1 }
 */
const parseSimpleRoll = roll => mapToRoll( parseSimple( roll ));

module.exports = parseSimpleRoll;

},{"../mapper":12,"../parser":18}],9:[function(require,module,exports){
const { parseWod } = require( '../parser' );
const { mapToWodRoll } = require( '../mapper' );

/**
 * Parses World of Darkness (WoD) roll notation.
 *
 * @func
 * @since v2.0.0
 * @param {String} roll
 * @return {WodRoll}
 * @see parse
 * @see parseSimpleRoll
 * @see parseClassicRoll
 * @example
 * parseWodRoll('d10>6');     //=> { dice: 10, count: 1, again: false, success: 6, fail: 0 }
 * parseWodRoll('2d10!>6');   //=> { dice: 10, count: 2, again: true, success: 6, fail: 0 }
 * parseWodRoll('4d10!>8f1'); //=> { dice: 10, count: 4, again: true, success: 8, fail: 1 }
 */
const parseWodRoll = roll => mapToWodRoll( parseWod( roll ));

module.exports = parseWodRoll;

},{"../mapper":12,"../parser":18}],10:[function(require,module,exports){
const { isAbsent } = require( './normalizer' );
const Roll = require( './object/Roll' );
const WodRoll = require( './object/WodRoll' );

function convertToRoll( object = {}) {
  const { dice, count, modifier } = object || {};

  return new Roll( dice, count, modifier );
}

function convertToWodRoll( object = {}) {
  const { dice, count, again, success, fail } = object || {};

  return new WodRoll( dice, count, again, success, fail );
}

/**
 * Converts any arguments to `Roll` or `WodRoll` object.
 * If passed argument has `again`, `success` or `fail` property, the function will return `WodRoll`.
 * Otherwise, `Roll` will be returned.
 *
 * @func
 * @alias convert
 * @since v2.1.0
 * @param {Object} object - `Roll`, `WodRoll` or similar object.
 * @return {Roll|WodRoll} Result of converion.
 * @example
 * convert({ dice: 6 }); //=> new Roll( 6 )
 * convert({ modifier: 6 }); //=> new Roll( undefined, undefined, 6 )
 * convert({ dice: 10, count: 5, success: 5 }); //=> new WodRoll( 10, 5, undefined, 5 )
 */
function convertToAnyRoll( object = {}) {
  const { again, success, fail } = object || {};

  if ( isAbsent( again ) && isAbsent( success ) && isAbsent( fail )) {
    return convertToRoll( object );
  } // else
  return convertToWodRoll( object );
}

module.exports = {
  convertToRoll,
  convertToWodRoll,
  convertToAnyRoll,
};

},{"./normalizer":13,"./object/Roll":15,"./object/WodRoll":17}],11:[function(require,module,exports){
// Multiple instances of each notation exists for purposes of readability
// Each grammar is an array of RegExps
module.exports = {
  simple: [
    /^(\d+)(?:\s+(\d+)(?:\s+([+-]?\d+))?)?$/,        // 1 20 4 || 1 20 +4 5 || 1 20 -4 5 20
  ],
  classic: [
    /^(\d*)(?:[dD])(\d+)([+-]\d+)?$/,                // d20 || 1d20 || d20+4 || 1d20-4
  ],
  wod: [
    /^(\d*)(?:[dD])(\d+)(!?)$/,                      // d10 || d10! || 1d10 || 1d10!
    /^(\d*)(?:[dD])(\d+)(!?)(?:>)(\d+)(?:f(\d+))?$/, // d10>6 || 1d10>6 || 1d10!>6 || 1d10!>6f1
  ],
};

},{}],12:[function(require,module,exports){
const { normalizeRegexResult, isAbsent } = require( './normalizer' );
const Roll = require( './object/Roll' );
const WodRoll = require( './object/WodRoll' );

// map :: Object -> [Array | null]
//   Takes a result of RegExp.prototype.exec() and returns an Array of integers, strings, and null
function map( result ) {
  const invalid = !result || result.length < 2;
  return invalid ? null : ( result.slice( 1 ).map( normalizeRegexResult ));
}

const orderArguments = limit => ( values ) => {
  if ( !values || values.length === 0 ) {
    return null;
  }

  // Minimum grammar accepts 2 values. If second is not set, it is mapped to `null`
  const sinlge = values.length === 1 || values.slice( 1 ).every( isAbsent );
  if ( sinlge ) {
    return [ values[ 0 ] ];
  }

  return [ values[ 1 ], values[ 0 ], ...values.slice( 2, limit ) ];
};

const orderRollArguments = orderArguments( 3 );
const orderWodRollArguments = orderArguments( 5 );

// mapToRoll :: Object -> [Object | null]
//   Orders map() values with orderArguments(), takes the result
//   and returns a Roll object or null
const mapToRoll = ( result ) => {
  const values = orderRollArguments( map( result ));
  return values ? new Roll( ...values ) : null;
};

// mapToWodRoll :: Object -> [Object | null]
//   Orders map() values with orderArguments(), takes the result
//   and returns a WodRoll object or null
const mapToWodRoll = ( result ) => {
  const values = orderWodRollArguments( map( result ));
  return values ? new WodRoll( ...values ) : null;
};

module.exports = {
  map,
  orderArguments,
  mapToRoll,
  mapToWodRoll,
};

},{"./normalizer":13,"./object/Roll":15,"./object/WodRoll":17}],13:[function(require,module,exports){
// isPositiveInteger :: Number -> Boolean
const isPositiveInteger = value => Number.isInteger( value ) && value > 0;

// fixInvalid :: Number -> Any -> Number
const fixInvalid = backup => value => ( isPositiveInteger( value ) ? value : backup );

// normalizeInteger :: Any -> Number
const normalizeInteger = value => ( Number.isInteger( value ) ? value : 0 );

// normalizeRollResult :: Any -> Number
const normalizeRollResult = fixInvalid( 1 );

// normalizeTop :: Number -> Number -> Number
const normalizeTop = max => top => Math.min( fixInvalid( Number.MAX_SAFE_INTEGER )( top ), max );
// normalizeTop :: Number -> Number -> Number
const normalizeBottom = max => bottom => Math.min( fixInvalid( 0 )( bottom ), max );

// normalizeWodBorders :: ( Number, Number, Number ) -> [ Number, Number ]
const normalizeWodBorders = ( bottom, top, max ) => {
  const b = normalizeTop( max )( top );
  const a = normalizeBottom( b - 1 )( bottom );
  return [ a, b ];
};

// isDefined :: Any -> Boolean
//   Checks for the existence of the value
const isDefined = value => value !== undefined && value !== null;

// isAbsent :: Any -> Boolean
//   Checks for absence of the values from RegExp execution result.
const isAbsent = value => value === undefined || value === null || value === '';

// toInteger :: a -> Number | a
// a = String | Any
const toInteger = value => parseInt( value, 10 ) || value;


// normalizeRegexResult :: Any -> null | Number | String
const normalizeRegexResult = value => ( isAbsent( value ) ? null : toInteger( value ));

module.exports = {
  isAbsent,
  isDefined,
  fixInvalid,
  normalizeInteger,
  normalizeRollResult,
  normalizeTop,
  normalizeBottom,
  normalizeWodBorders,
  normalizeRegexResult,
};

},{}],14:[function(require,module,exports){
const { resultNotation } = require( '../stringifier' );
/**
 * A class that represents a dice roll result
 * @class
 * @classdesc A class that represents a dice roll result
 * @since v2.0.0
 * @param {String} notation - A roll notation
 * @param {Number} value - A numeric representation of roll result, like total summ or success count
 * @param {Array} rolls - An array of rolls dome
 * @see Roll
 * @see WodRoll
 */
function Result( notation, value, rolls ) {
  this.notation = notation;
  this.value = value;
  this.rolls = rolls;
}

Result.prototype.toString = function toString() {
  return resultNotation( this );
};

module.exports = Result;

},{"../stringifier":21}],15:[function(require,module,exports){
const { fixInvalid, normalizeInteger } = require( '../normalizer' );
const { classicNotation } = require( '../stringifier' );

const positiveInteger = fixInvalid( 1 );

/**
 * A class that represents a dice roll from D&D setting
 * @class
 * @classdesc A class that represents a dice roll from D&D setting
 * @since v2.0.0
 * @param {Number} dice - A number of dice faces
 * @param {Number} count - A number of dices
 * @param {Number} modifier - A modifier, that should be added/sustracted from result
 * @see WodRoll
 */
function Roll( dice = 20, count = 1, modifier = 0 ) {
  this.dice = positiveInteger( dice );
  this.count = positiveInteger( count );
  this.modifier = normalizeInteger( modifier );
}

Roll.prototype.toString = function toString() {
  return classicNotation( this );
};

module.exports = Roll;

},{"../normalizer":13,"../stringifier":21}],16:[function(require,module,exports){
module.exports = {
  simple: 'simple',
  classic: 'classic',
  wod: 'wod',
};

},{}],17:[function(require,module,exports){
const { fixInvalid, normalizeWodBorders } = require( '../normalizer' );
const { wodNotation } = require( '../stringifier' );

const positiveInteger = fixInvalid( 1 );

/**
 * A class that represents a dice roll from World of Darkness setting
 * @class
 * @classdesc A class that represents a dice roll from World of Darkness setting
 * @since v2.0.0
 * @param {Number} dice - A number of dice faces
 * @param {Number} count - A number of dices
 * @param {Boolean} again - A flag for "10 Again" rolls policy
 * @param {Number} success - A minimum value, that counts as success
 * @param {Number} fail - A maximum value, that counts as failure
 * @see Roll
 */
function WodRoll( dice = 10, count = 1, again = false, success = 6, fail ) {
  this.dice = positiveInteger( dice );
  this.count = positiveInteger( count );
  this.again = !!again;
  [ this.fail, this.success ] = normalizeWodBorders( fail, success, this.dice );
}

WodRoll.prototype.toString = function toString() {
  return wodNotation( this );
};

module.exports = WodRoll;

},{"../normalizer":13,"../stringifier":21}],18:[function(require,module,exports){
const grammar = require( './grammar' );
const Type = require( './object/Type' );

// isUnary :: Array -> Boolean
const isUnary = array => array.length === 1;

// makeParser :: ( [ RegExp ], String ) -> ( String -> [ String | Undefined ] )
const makeParser = ( grammarSet, type ) => {
  if ( isUnary( grammarSet )) {
    return ( roll ) => {
      const result = grammarSet[ 0 ].exec( roll );
      if ( result ) {
        result.type = type;
      }
      return result;
    };
  }
  return ( roll ) => {
    let result = null;
    grammarSet.some( regex => ( result = regex.exec( roll )));
    if ( result ) {
      result.type = type;
    }
    return result;
  };
};

// parseSimple :: String -> [ String | Undefined ]
const parseSimple = makeParser( grammar.simple, Type.simple );
// parseClassic :: String -> [ String | Undefined ]
const parseClassic = makeParser( grammar.classic, Type.classic );
// parseWod :: String -> [ String | Undefined ]
const parseWod = makeParser( grammar.wod, Type.wod );
// parseAny :: String -> [ String | Undefined ]
const parseAny = roll => parseClassic( roll ) || parseSimple( roll ) || parseWod( roll );

module.exports = {
  makeParser,
  parseSimple,
  parseClassic,
  parseWod,
  parseAny,
};

},{"./grammar":11,"./object/Type":16}],19:[function(require,module,exports){
// random :: Number -> Number -> Number
//   Generates random integer from the range of [ min, max ] values
const random = min => max => Math.floor( Math.random() * (( max + 1 ) - min )) + min;

/**
 * Generates random positive integer from `1` to `max`.
 *
 * @func
 * @alias random
 * @since v2.0.0
 * @param {Number} max - maximum possible generated value
 * @return {Number} Positive integer, from `1` to `max`
 * @example
 * random(100); //=> 77 - random number from 1 to 100
 * random(1);   //=>  1 - always rolls 1
 */
const randomRoll = random( 1 );

module.exports = {
  random,
  randomRoll,
};

},{}],20:[function(require,module,exports){
const { randomRoll } = require( './random' );
const { normalizeRollResult, isDefined } = require( './normalizer' );
const { convertToRoll, convertToWodRoll, convertToAnyRoll } = require( './converter' );
const Result = require( './object/Result' );
const Roll = require( './object/Roll' );
const WodRoll = require( './object/WodRoll' );


/**
 * Rolls the dice from `Roll` object.
 *
 * @func
 * @since v2.0.0
 * @param {Roll} roll - `Roll` object or similar
 * @return {Result}
 * @see roll
 * @see rollWod
 * @example
 * rollClassic(new Roll(10, 2, -1)); //=> { notation: '2d10-1', value: 14, rolls: [ 7, 8 ] }
 * rollClassic({ dice: 6 }); //=> { notation: 'd6', value: 4, rolls: [ 4 ] }
 */
function rollClassic( roll ) {
  const data = roll instanceof Roll ? roll : convertToRoll( roll );
  const { dice, count, modifier } = data;

  const rolls = [ ...new Array( count ) ].map(() => randomRoll( dice ));
  const summ = rolls.reduce(( prev, curr ) => prev + curr, 0 );
  const result = normalizeRollResult( summ + modifier );

  return new Result( data.toString(), result, rolls );
}

/**
 * Rolls the dice from `WodRoll` object.
 *
 * @func
 * @since v2.0.0
 * @param {WodRoll} roll - `WodRoll` object or similar
 * @return {Result}
 * @see roll
 * @see rollClassic
 * @example
 * rollWod(new WodRoll(10, 4, true, 8)); //=> { notation: '4d10!>8', value: 2, rolls: [3,10,7,9,5] }
 * rollWod({ dice: 8, count: 3 }); //=> { notation: '3d8>6', value: 2, rolls: [ 7, 3, 9 ] }
 */
function rollWod( roll ) {
  const data = roll instanceof WodRoll ? roll : convertToWodRoll( roll );
  const { dice, count, again, success, fail } = data;

  const rolls = [];

  let i = count;
  while ( i > 0 ) {
    const value = randomRoll( dice );
    rolls.push( value );
    // Check for "10 Again" flag
    // `repeatLimit` will prevent infinite loop, for cases like `d1!>1`
    const repeatLimit = 100;
    if ( value !== dice || !again || rolls.length > repeatLimit ) {
      i -= 1;
    }
  }

  const result = rolls.reduce(( suc, val ) => {
    if ( val >= success ) {
      return suc + 1;
    } else if ( val <= fail ) {
      return suc - 1;
    }
    return suc;
  }, 0 );

  return new Result( data.toString(), Math.max( result, 0 ), rolls );
}

/**
 * Rolls the dice from `Roll` or `WodRoll` objects.
 *
 * @func
 * @alias roll
 * @since v2.0.0
 * @param {Roll|WodRoll|Object} roll - `Roll`, `WodRoll` or similar object.
 * @return {Result} Returns `Result` for defined parameters, otherwise returns `null`.
 * @see rollClassic
 * @see rollWod
 * @example
 * roll(new Roll(10, 2, -1)); //=> { notation: '2d10-1', value: 14, rolls: [ 7, 8 ] }
 * roll({ dice: 6 }); //=> { notation: 'd6', value: 4, rolls: [ 4 ] }
 * roll(new WodRoll(10, 4, true, 8)); //=> { notation: '4d10!>8', value: 2, rolls: [3,10,7,9,5] }
 * roll({ dice: 8, count: 3, again: true }); //=> { notation: '3d8!>6', value: 2, rolls: [7,3,9 ] }
 * roll( null ); //=> null
 */
function rollAny( roll ) {
  if ( roll instanceof Roll ) {
    return rollClassic( roll );
  } else if ( roll instanceof WodRoll ) {
    return rollWod( roll );
  }
  return isDefined( roll ) ? rollAny( convertToAnyRoll( roll )) : null;
}

module.exports = {
  rollClassic,
  rollWod,
  rollAny,
};

},{"./converter":10,"./normalizer":13,"./object/Result":14,"./object/Roll":15,"./object/WodRoll":17,"./random":19}],21:[function(require,module,exports){
function simpleNotation( roll ) {
  const count = roll.count > 1 ? `${ roll.count } ` : '';
  const modifier = roll.modifier ? ` ${ roll.modifier }` : '';

  return `${ count }${ roll.dice }${ modifier }`;
}

function classicNotation( roll ) {
  const count = roll.count > 1 ? roll.count : '';
  const modifier = roll.modifier > 0 ? `+${ roll.modifier }` : ( roll.modifier || '' );

  return `${ count }d${ roll.dice }${ modifier }`;
}

function wodNotation( roll ) {
  const count = roll.count > 1 ? roll.count : '';
  const again = roll.again ? '!' : '';
  const fail = roll.fail > 0 ? `f${ roll.fail }` : '';

  return `${ count }d${ roll.dice }${ again }>${ roll.success }${ fail }`;
}

function resultNotation( result ) {
  const { notation, value, rolls } = result;
  return `(${ notation }) ${ value } [${ rolls }]`;
}

module.exports = {
  simpleNotation,
  classicNotation,
  wodNotation,
  resultNotation,
};

},{}]},{},[1])(1)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJpbmRleC5qcyIsInNyYy9jb21wbGV4L3BhcnNlLmpzIiwic3JjL2NvbXBsZXgvcGFyc2VBbmRSb2xsLmpzIiwic3JjL2NvbXBsZXgvcGFyc2VBbmRSb2xsQ2xhc3NpYy5qcyIsInNyYy9jb21wbGV4L3BhcnNlQW5kUm9sbFNpbXBsZS5qcyIsInNyYy9jb21wbGV4L3BhcnNlQW5kUm9sbFdvZC5qcyIsInNyYy9jb21wbGV4L3BhcnNlQ2xhc3NpY1JvbGwuanMiLCJzcmMvY29tcGxleC9wYXJzZVNpbXBsZVJvbGwuanMiLCJzcmMvY29tcGxleC9wYXJzZVdvZFJvbGwuanMiLCJzcmMvY29udmVydGVyLmpzIiwic3JjL2dyYW1tYXIuanMiLCJzcmMvbWFwcGVyLmpzIiwic3JjL25vcm1hbGl6ZXIuanMiLCJzcmMvb2JqZWN0L1Jlc3VsdC5qcyIsInNyYy9vYmplY3QvUm9sbC5qcyIsInNyYy9vYmplY3QvVHlwZS5qcyIsInNyYy9vYmplY3QvV29kUm9sbC5qcyIsInNyYy9wYXJzZXIuanMiLCJzcmMvcmFuZG9tLmpzIiwic3JjL3JvbGxlci5qcyIsInNyYy9zdHJpbmdpZmllci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLyogZXNsaW50IGdsb2JhbC1yZXF1aXJlOiBcIm9mZlwiICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgUm9sbDogcmVxdWlyZSggJy4vc3JjL29iamVjdC9Sb2xsJyApLFxuICBXb2RSb2xsOiByZXF1aXJlKCAnLi9zcmMvb2JqZWN0L1dvZFJvbGwnICksXG4gIFJlc3VsdDogcmVxdWlyZSggJy4vc3JjL29iamVjdC9SZXN1bHQnICksXG5cbiAgcGFyc2U6IHJlcXVpcmUoICcuL3NyYy9jb21wbGV4L3BhcnNlJyApLFxuICBwYXJzZUNsYXNzaWNSb2xsOiByZXF1aXJlKCAnLi9zcmMvY29tcGxleC9wYXJzZUNsYXNzaWNSb2xsJyApLFxuICBwYXJzZVNpbXBsZVJvbGw6IHJlcXVpcmUoICcuL3NyYy9jb21wbGV4L3BhcnNlU2ltcGxlUm9sbCcgKSxcbiAgcGFyc2VXb2RSb2xsOiByZXF1aXJlKCAnLi9zcmMvY29tcGxleC9wYXJzZVdvZFJvbGwnICksXG5cbiAgcm9sbDogcmVxdWlyZSggJy4vc3JjL3JvbGxlcicgKS5yb2xsQW55LFxuICByb2xsQ2xhc3NpYzogcmVxdWlyZSggJy4vc3JjL3JvbGxlcicgKS5yb2xsQ2xhc3NpYyxcbiAgcm9sbFdvZDogcmVxdWlyZSggJy4vc3JjL3JvbGxlcicgKS5yb2xsV29kLFxuXG4gIHBhcnNlQW5kUm9sbDogcmVxdWlyZSggJy4vc3JjL2NvbXBsZXgvcGFyc2VBbmRSb2xsJyApLFxuICBwYXJzZUFuZFJvbGxTaW1wbGU6IHJlcXVpcmUoICcuL3NyYy9jb21wbGV4L3BhcnNlQW5kUm9sbFNpbXBsZScgKSxcbiAgcGFyc2VBbmRSb2xsQ2xhc3NpYzogcmVxdWlyZSggJy4vc3JjL2NvbXBsZXgvcGFyc2VBbmRSb2xsQ2xhc3NpYycgKSxcbiAgcGFyc2VBbmRSb2xsV29kOiByZXF1aXJlKCAnLi9zcmMvY29tcGxleC9wYXJzZUFuZFJvbGxXb2QnICksXG5cbiAgcmFuZG9tOiByZXF1aXJlKCAnLi9zcmMvcmFuZG9tJyApLnJhbmRvbVJvbGwsXG5cbiAgY29udmVydDogcmVxdWlyZSggJy4vc3JjL2NvbnZlcnRlcicgKS5jb252ZXJ0VG9BbnlSb2xsLFxufTtcbiIsImNvbnN0IHsgcGFyc2VBbnkgfSA9IHJlcXVpcmUoICcuLi9wYXJzZXInICk7XG5jb25zdCB7IG1hcFRvUm9sbCwgbWFwVG9Xb2RSb2xsIH0gPSByZXF1aXJlKCAnLi4vbWFwcGVyJyApO1xuY29uc3QgVHlwZSA9IHJlcXVpcmUoICcuLi9vYmplY3QvVHlwZScgKTtcblxuLyoqXG4gKiBQYXJzZXMgc2ltcGxpZmllZCwgY2xhc3NpYyBvciBXb0Qgcm9sbCBub3RhdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQHNpbmNlIHYyLjAuMFxuICogQHBhcmFtIHtTdHJpbmd9IHJvbGxcbiAqIEByZXR1cm4ge1JvbGx8V29kUm9sbHxudWxsfVxuICogQHNlZSBwYXJzZVNpbXBsZVJvbGxcbiAqIEBzZWUgcGFyc2VDbGFzc2ljUm9sbFxuICogQHNlZSBwYXJzZVdvZFJvbGxcbiAqIEBleGFtcGxlXG4gKiBwYXJzZSgnMiAxMCAtMScpOyAgIC8vPT4geyBkaWNlOiAxMCwgY291bnQ6IDIsIG1vZGlmaWVyOiAtMSB9XG4gKiBwYXJzZSgnMmQxMCsxJyk7ICAgIC8vPT4geyBkaWNlOiAxMCwgY291bnQ6IDIsIG1vZGlmaWVyOiAxIH1cbiAqIHBhcnNlKCc0ZDEwIT44ZjEnKTsgLy89PiB7IGRpY2U6IDEwLCBjb3VudDogNCwgYWdhaW46IHRydWUsIHN1Y2Nlc3M6IDgsIGZhaWw6IDEgfVxuICogcGFyc2UoJ3h5eicpOyAgICAgICAvLz0+IG51bGxcbiAqL1xuZnVuY3Rpb24gcGFyc2UoIHJvbGwgKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHBhcnNlQW55KCByb2xsICk7XG4gIGNvbnN0IHR5cGUgPSByZXN1bHQgPyByZXN1bHQudHlwZSA6ICcnO1xuXG4gIHN3aXRjaCAoIHR5cGUgKSB7XG4gICAgY2FzZSBUeXBlLnNpbXBsZTpcbiAgICAgIHJldHVybiBtYXBUb1JvbGwoIHJlc3VsdCApO1xuICAgIGNhc2UgVHlwZS5jbGFzc2ljOlxuICAgICAgcmV0dXJuIG1hcFRvUm9sbCggcmVzdWx0ICk7XG4gICAgY2FzZSBUeXBlLndvZDpcbiAgICAgIHJldHVybiBtYXBUb1dvZFJvbGwoIHJlc3VsdCApO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlO1xuIiwiY29uc3QgeyByb2xsQW55IH0gPSByZXF1aXJlKCAnLi4vcm9sbGVyJyApO1xuY29uc3QgcGFyc2UgPSByZXF1aXJlKCAnLi9wYXJzZScgKTtcblxuLyoqXG4gKiBQYXJzZXMgc2ltcGxpZmllZCwgY2xhc3NpYyBvciBXb0Qgcm9sbCBub3RhdGlvbiBhbmQgdGhlbiByb2xscyB0aGUgZGljZS5cbiAqXG4gKiBAZnVuY1xuICogQHNpbmNlIHYyLjAuMFxuICogQHBhcmFtIHtTdHJpbmd9IHJvbGxcbiAqIEByZXR1cm4ge1Jlc3VsdHxudWxsfSBSZXR1cm5zIGBSZXN1bHRgIGZvciBkZWZpbmVkIHBhcmFtZXRlcnMsIG90aGVyd2lzZSByZXR1cm5zIGBudWxsYC5cbiAqIEBzZWUgcGFyc2VBbmRSb2xsU2ltcGxlXG4gKiBAc2VlIHBhcnNlQW5kUm9sbENsYXNzaWNcbiAqIEBzZWUgcGFyc2VBbmRSb2xsV29kXG4gKiBAZXhhbXBsZVxuICogcGFyc2VBbmRSb2xsKCcyIDEwIC0xJyk7ICAgLy89PiB7IG5vdGF0aW9uOiAnMmQxMC0xJywgdmFsdWU6IDE0LCByb2xsczogWyA3LCA4IF0gfVxuICogcGFyc2VBbmRSb2xsKCcyZDEwKzEnKTsgICAgLy89PiB7IG5vdGF0aW9uOiAnMmQxMCsxJywgdmFsdWU6IDksIHJvbGxzOiBbIDIsIDYgXSB9XG4gKiBwYXJzZUFuZFJvbGwoJzRkMTAhPjhmMScpOyAvLz0+IHsgbm90YXRpb246ICc0ZDEwIT44ZjEnLCB2YWx1ZTogMiwgcm9sbHM6IFsgMywgMTAsIDcsIDksIDUgXSB9XG4gKi9cbmNvbnN0IHBhcnNlQW5kUm9sbCA9IHJvbGwgPT4gcm9sbEFueSggcGFyc2UoIHJvbGwgKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VBbmRSb2xsO1xuIiwiY29uc3QgeyByb2xsQ2xhc3NpYyB9ID0gcmVxdWlyZSggJy4uL3JvbGxlcicgKTtcbmNvbnN0IHBhcnNlQ2xhc3NpY1JvbGwgPSByZXF1aXJlKCAnLi9wYXJzZUNsYXNzaWNSb2xsJyApO1xuXG4vKipcbiAqIFBhcnNlcyBjbGFzc2ljIG5vdGF0aW9uIGFuZCB0aGVuIHJvbGxzIHRoZSBkaWNlLlxuICpcbiAqIEBmdW5jXG4gKiBAc2luY2UgdjIuMC4wXG4gKiBAcGFyYW0ge1N0cmluZ30gcm9sbFxuICogQHJldHVybiB7UmVzdWx0fVxuICogQHNlZSBwYXJzZUFuZFJvbGxcbiAqIEBzZWUgcGFyc2VBbmRSb2xsU2ltcGxlXG4gKiBAc2VlIHBhcnNlQW5kUm9sbFdvZFxuICogQGV4YW1wbGVcbiAqIHBhcnNlQW5kUm9sbENsYXNzaWMoJzJkMTArMScpOyAgLy89PiB7IG5vdGF0aW9uOiAnMmQxMCsxJywgdmFsdWU6IDksIHJvbGxzOiBbIDIsIDYgXSB9XG4gKiBwYXJzZUFuZFJvbGxDbGFzc2ljKCdkNicpOyAgICAgIC8vPT4geyBub3RhdGlvbjogJ2Q2JywgdmFsdWU6IDMsIHJvbGxzOiBbIDMgXSB9XG4gKi9cbmNvbnN0IHBhcnNlQW5kUm9sbENsYXNzaWMgPSByb2xsID0+IHJvbGxDbGFzc2ljKCBwYXJzZUNsYXNzaWNSb2xsKCByb2xsICkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlQW5kUm9sbENsYXNzaWM7XG4iLCJjb25zdCB7IHJvbGxDbGFzc2ljIH0gPSByZXF1aXJlKCAnLi4vcm9sbGVyJyApO1xuY29uc3QgcGFyc2VTaW1wbGVSb2xsID0gcmVxdWlyZSggJy4vcGFyc2VTaW1wbGVSb2xsJyApO1xuXG4vKipcbiAqIFBhcnNlcyBzaW1wbGUgbm90YXRpb24gYW5kIHRoZW4gcm9sbHMgdGhlIGRpY2UuXG4gKlxuICogQGZ1bmNcbiAqIEBzaW5jZSB2Mi4wLjBcbiAqIEBwYXJhbSB7U3RyaW5nfSByb2xsXG4gKiBAcmV0dXJuIHtSZXN1bHR9XG4gKiBAc2VlIHBhcnNlQW5kUm9sbFxuICogQHNlZSBwYXJzZUFuZFJvbGxTaW1wbGVcbiAqIEBzZWUgcGFyc2VBbmRSb2xsV29kXG4gKiBAZXhhbXBsZVxuICogcGFyc2VBbmRSb2xsU2ltcGxlKCcyIDEwIC0xJyk7IC8vPT4geyBub3RhdGlvbjogJzJkMTAtMScsIHZhbHVlOiAxNCwgcm9sbHM6IFsgNywgOCBdIH1cbiAqL1xuY29uc3QgcGFyc2VBbmRSb2xsU2ltcGxlID0gcm9sbCA9PiByb2xsQ2xhc3NpYyggcGFyc2VTaW1wbGVSb2xsKCByb2xsICkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlQW5kUm9sbFNpbXBsZTtcbiIsImNvbnN0IHsgcm9sbFdvZCB9ID0gcmVxdWlyZSggJy4uL3JvbGxlcicgKTtcbmNvbnN0IHBhcnNlV29kUm9sbCA9IHJlcXVpcmUoICcuL3BhcnNlV29kUm9sbCcgKTtcblxuLyoqXG4gKiBQYXJzZXMgV29EIHJvbGwgbm90YXRpb24gYW5kIHRoZW4gcm9sbHMgdGhlIGRpY2UuXG4gKlxuICogQGZ1bmNcbiAqIEBzaW5jZSB2Mi4wLjBcbiAqIEBwYXJhbSB7U3RyaW5nfSByb2xsXG4gKiBAcmV0dXJuIHtSZXN1bHR9XG4gKiBAc2VlIHBhcnNlQW5kUm9sbFxuICogQHNlZSBwYXJzZUFuZFJvbGxTaW1wbGVcbiAqIEBzZWUgcGFyc2VBbmRSb2xsQ2xhc3NpY1xuICogQGV4YW1wbGVcbiAqIHBhcnNlQW5kUm9sbFdvZCgnMmQxMD42Jyk7ICAgIC8vPT4geyBub3RhdGlvbjogJzJkMTA+NicsIHZhbHVlOiAxLCByb2xsczogWyA1LCAxMCBdIH1cbiAqIHBhcnNlQW5kUm9sbFdvZCgnNGQxMCE+OGYxJyk7IC8vPT4geyBub3RhdGlvbjogJzRkMTAhPjhmMScsIHZhbHVlOiAyLCByb2xsczogWyAzLCAxMCwgNywgOSwgNSBdIH1cbiAqL1xuY29uc3QgcGFyc2VBbmRSb2xsV29kID0gcm9sbCA9PiByb2xsV29kKCBwYXJzZVdvZFJvbGwoIHJvbGwgKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VBbmRSb2xsV29kO1xuIiwiY29uc3QgeyBwYXJzZUNsYXNzaWMgfSA9IHJlcXVpcmUoICcuLi9wYXJzZXInICk7XG5jb25zdCB7IG1hcFRvUm9sbCB9ID0gcmVxdWlyZSggJy4uL21hcHBlcicgKTtcblxuLyoqXG4gKiBQYXJzZXMgY2xhc3NpYyBEbkQgcm9sbCBub3RhdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQHNpbmNlIHYyLjAuMFxuICogQHBhcmFtIHtTdHJpbmd9IHJvbGxcbiAqIEByZXR1cm4ge1JvbGx9XG4gKiBAc2VlIHBhcnNlXG4gKiBAc2VlIHBhcnNlU2ltcGxlUm9sbFxuICogQHNlZSBwYXJzZVdvZFJvbGxcbiAqIEBleGFtcGxlXG4gKiBwYXJzZUNsYXNzaWNSb2xsKCdkMTAnKTsgICAgLy89PiB7IGRpY2U6IDEwLCBjb3VudDogMSwgbW9kaWZpZXI6IDAgfVxuICogcGFyc2VDbGFzc2ljUm9sbCgnMmQxMCcpOyAgIC8vPT4geyBkaWNlOiAxMCwgY291bnQ6IDIsIG1vZGlmaWVyOiAwIH1cbiAqIHBhcnNlQ2xhc3NpY1JvbGwoJ2QxMCsxJyk7ICAvLz0+IHsgZGljZTogMTAsIGNvdW50OiAxLCBtb2RpZmllcjogMSB9XG4gKiBwYXJzZUNsYXNzaWNSb2xsKCcyZDEwLTEnKTsgLy89PiB7IGRpY2U6IDEwLCBjb3VudDogMiwgbW9kaWZpZXI6IC0xIH1cbiAqL1xuY29uc3QgcGFyc2VDbGFzc2ljUm9sbCA9IHJvbGwgPT4gbWFwVG9Sb2xsKCBwYXJzZUNsYXNzaWMoIHJvbGwgKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VDbGFzc2ljUm9sbDtcbiIsImNvbnN0IHsgcGFyc2VTaW1wbGUgfSA9IHJlcXVpcmUoICcuLi9wYXJzZXInICk7XG5jb25zdCB7IG1hcFRvUm9sbCB9ID0gcmVxdWlyZSggJy4uL21hcHBlcicgKTtcblxuLyoqXG4gKiBQYXJzZXMgc2ltcGxlIHJvbGwgbm90YXRpb24gKHNwYWNlIHNlcGFyYXRlZCB2YWx1ZXMpLlxuICpcbiAqIEBmdW5jXG4gKiBAc2luY2UgdjIuMC4wXG4gKiBAcGFyYW0ge1N0cmluZ30gcm9sbFxuICogQHJldHVybiB7Um9sbH1cbiAqIEBzZWUgcGFyc2VcbiAqIEBzZWUgcGFyc2VDbGFzc2ljUm9sbFxuICogQHNlZSBwYXJzZVdvZFJvbGxcbiAqIEBleGFtcGxlXG4gKiBwYXJzZVNpbXBsZVJvbGwoJzEwJyk7ICAgICAgLy89PiB7IGRpY2U6IDEwLCBjb3VudDogMSwgbW9kaWZpZXI6IDAgfVxuICogcGFyc2VTaW1wbGVSb2xsKCcyIDEwJyk7ICAgIC8vPT4geyBkaWNlOiAxMCwgY291bnQ6IDIsIG1vZGlmaWVyOiAwIH1cbiAqIHBhcnNlU2ltcGxlUm9sbCgnMiAxMCAtMScpOyAvLz0+IHsgZGljZTogMTAsIGNvdW50OiAyLCBtb2RpZmllcjogLTEgfVxuICovXG5jb25zdCBwYXJzZVNpbXBsZVJvbGwgPSByb2xsID0+IG1hcFRvUm9sbCggcGFyc2VTaW1wbGUoIHJvbGwgKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VTaW1wbGVSb2xsO1xuIiwiY29uc3QgeyBwYXJzZVdvZCB9ID0gcmVxdWlyZSggJy4uL3BhcnNlcicgKTtcbmNvbnN0IHsgbWFwVG9Xb2RSb2xsIH0gPSByZXF1aXJlKCAnLi4vbWFwcGVyJyApO1xuXG4vKipcbiAqIFBhcnNlcyBXb3JsZCBvZiBEYXJrbmVzcyAoV29EKSByb2xsIG5vdGF0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAc2luY2UgdjIuMC4wXG4gKiBAcGFyYW0ge1N0cmluZ30gcm9sbFxuICogQHJldHVybiB7V29kUm9sbH1cbiAqIEBzZWUgcGFyc2VcbiAqIEBzZWUgcGFyc2VTaW1wbGVSb2xsXG4gKiBAc2VlIHBhcnNlQ2xhc3NpY1JvbGxcbiAqIEBleGFtcGxlXG4gKiBwYXJzZVdvZFJvbGwoJ2QxMD42Jyk7ICAgICAvLz0+IHsgZGljZTogMTAsIGNvdW50OiAxLCBhZ2FpbjogZmFsc2UsIHN1Y2Nlc3M6IDYsIGZhaWw6IDAgfVxuICogcGFyc2VXb2RSb2xsKCcyZDEwIT42Jyk7ICAgLy89PiB7IGRpY2U6IDEwLCBjb3VudDogMiwgYWdhaW46IHRydWUsIHN1Y2Nlc3M6IDYsIGZhaWw6IDAgfVxuICogcGFyc2VXb2RSb2xsKCc0ZDEwIT44ZjEnKTsgLy89PiB7IGRpY2U6IDEwLCBjb3VudDogNCwgYWdhaW46IHRydWUsIHN1Y2Nlc3M6IDgsIGZhaWw6IDEgfVxuICovXG5jb25zdCBwYXJzZVdvZFJvbGwgPSByb2xsID0+IG1hcFRvV29kUm9sbCggcGFyc2VXb2QoIHJvbGwgKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VXb2RSb2xsO1xuIiwiY29uc3QgeyBpc0Fic2VudCB9ID0gcmVxdWlyZSggJy4vbm9ybWFsaXplcicgKTtcbmNvbnN0IFJvbGwgPSByZXF1aXJlKCAnLi9vYmplY3QvUm9sbCcgKTtcbmNvbnN0IFdvZFJvbGwgPSByZXF1aXJlKCAnLi9vYmplY3QvV29kUm9sbCcgKTtcblxuZnVuY3Rpb24gY29udmVydFRvUm9sbCggb2JqZWN0ID0ge30pIHtcbiAgY29uc3QgeyBkaWNlLCBjb3VudCwgbW9kaWZpZXIgfSA9IG9iamVjdCB8fCB7fTtcblxuICByZXR1cm4gbmV3IFJvbGwoIGRpY2UsIGNvdW50LCBtb2RpZmllciApO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0VG9Xb2RSb2xsKCBvYmplY3QgPSB7fSkge1xuICBjb25zdCB7IGRpY2UsIGNvdW50LCBhZ2Fpbiwgc3VjY2VzcywgZmFpbCB9ID0gb2JqZWN0IHx8IHt9O1xuXG4gIHJldHVybiBuZXcgV29kUm9sbCggZGljZSwgY291bnQsIGFnYWluLCBzdWNjZXNzLCBmYWlsICk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYW55IGFyZ3VtZW50cyB0byBgUm9sbGAgb3IgYFdvZFJvbGxgIG9iamVjdC5cbiAqIElmIHBhc3NlZCBhcmd1bWVudCBoYXMgYGFnYWluYCwgYHN1Y2Nlc3NgIG9yIGBmYWlsYCBwcm9wZXJ0eSwgdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGBXb2RSb2xsYC5cbiAqIE90aGVyd2lzZSwgYFJvbGxgIHdpbGwgYmUgcmV0dXJuZWQuXG4gKlxuICogQGZ1bmNcbiAqIEBhbGlhcyBjb252ZXJ0XG4gKiBAc2luY2UgdjIuMS4wXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IC0gYFJvbGxgLCBgV29kUm9sbGAgb3Igc2ltaWxhciBvYmplY3QuXG4gKiBAcmV0dXJuIHtSb2xsfFdvZFJvbGx9IFJlc3VsdCBvZiBjb252ZXJpb24uXG4gKiBAZXhhbXBsZVxuICogY29udmVydCh7IGRpY2U6IDYgfSk7IC8vPT4gbmV3IFJvbGwoIDYgKVxuICogY29udmVydCh7IG1vZGlmaWVyOiA2IH0pOyAvLz0+IG5ldyBSb2xsKCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgNiApXG4gKiBjb252ZXJ0KHsgZGljZTogMTAsIGNvdW50OiA1LCBzdWNjZXNzOiA1IH0pOyAvLz0+IG5ldyBXb2RSb2xsKCAxMCwgNSwgdW5kZWZpbmVkLCA1IClcbiAqL1xuZnVuY3Rpb24gY29udmVydFRvQW55Um9sbCggb2JqZWN0ID0ge30pIHtcbiAgY29uc3QgeyBhZ2Fpbiwgc3VjY2VzcywgZmFpbCB9ID0gb2JqZWN0IHx8IHt9O1xuXG4gIGlmICggaXNBYnNlbnQoIGFnYWluICkgJiYgaXNBYnNlbnQoIHN1Y2Nlc3MgKSAmJiBpc0Fic2VudCggZmFpbCApKSB7XG4gICAgcmV0dXJuIGNvbnZlcnRUb1JvbGwoIG9iamVjdCApO1xuICB9IC8vIGVsc2VcbiAgcmV0dXJuIGNvbnZlcnRUb1dvZFJvbGwoIG9iamVjdCApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29udmVydFRvUm9sbCxcbiAgY29udmVydFRvV29kUm9sbCxcbiAgY29udmVydFRvQW55Um9sbCxcbn07XG4iLCIvLyBNdWx0aXBsZSBpbnN0YW5jZXMgb2YgZWFjaCBub3RhdGlvbiBleGlzdHMgZm9yIHB1cnBvc2VzIG9mIHJlYWRhYmlsaXR5XG4vLyBFYWNoIGdyYW1tYXIgaXMgYW4gYXJyYXkgb2YgUmVnRXhwc1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNpbXBsZTogW1xuICAgIC9eKFxcZCspKD86XFxzKyhcXGQrKSg/OlxccysoWystXT9cXGQrKSk/KT8kLywgICAgICAgIC8vIDEgMjAgNCB8fCAxIDIwICs0IDUgfHwgMSAyMCAtNCA1IDIwXG4gIF0sXG4gIGNsYXNzaWM6IFtcbiAgICAvXihcXGQqKSg/OltkRF0pKFxcZCspKFsrLV1cXGQrKT8kLywgICAgICAgICAgICAgICAgLy8gZDIwIHx8IDFkMjAgfHwgZDIwKzQgfHwgMWQyMC00XG4gIF0sXG4gIHdvZDogW1xuICAgIC9eKFxcZCopKD86W2REXSkoXFxkKykoIT8pJC8sICAgICAgICAgICAgICAgICAgICAgIC8vIGQxMCB8fCBkMTAhIHx8IDFkMTAgfHwgMWQxMCFcbiAgICAvXihcXGQqKSg/OltkRF0pKFxcZCspKCE/KSg/Oj4pKFxcZCspKD86ZihcXGQrKSk/JC8sIC8vIGQxMD42IHx8IDFkMTA+NiB8fCAxZDEwIT42IHx8IDFkMTAhPjZmMVxuICBdLFxufTtcbiIsImNvbnN0IHsgbm9ybWFsaXplUmVnZXhSZXN1bHQsIGlzQWJzZW50IH0gPSByZXF1aXJlKCAnLi9ub3JtYWxpemVyJyApO1xuY29uc3QgUm9sbCA9IHJlcXVpcmUoICcuL29iamVjdC9Sb2xsJyApO1xuY29uc3QgV29kUm9sbCA9IHJlcXVpcmUoICcuL29iamVjdC9Xb2RSb2xsJyApO1xuXG4vLyBtYXAgOjogT2JqZWN0IC0+IFtBcnJheSB8IG51bGxdXG4vLyAgIFRha2VzIGEgcmVzdWx0IG9mIFJlZ0V4cC5wcm90b3R5cGUuZXhlYygpIGFuZCByZXR1cm5zIGFuIEFycmF5IG9mIGludGVnZXJzLCBzdHJpbmdzLCBhbmQgbnVsbFxuZnVuY3Rpb24gbWFwKCByZXN1bHQgKSB7XG4gIGNvbnN0IGludmFsaWQgPSAhcmVzdWx0IHx8IHJlc3VsdC5sZW5ndGggPCAyO1xuICByZXR1cm4gaW52YWxpZCA/IG51bGwgOiAoIHJlc3VsdC5zbGljZSggMSApLm1hcCggbm9ybWFsaXplUmVnZXhSZXN1bHQgKSk7XG59XG5cbmNvbnN0IG9yZGVyQXJndW1lbnRzID0gbGltaXQgPT4gKCB2YWx1ZXMgKSA9PiB7XG4gIGlmICggIXZhbHVlcyB8fCB2YWx1ZXMubGVuZ3RoID09PSAwICkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gTWluaW11bSBncmFtbWFyIGFjY2VwdHMgMiB2YWx1ZXMuIElmIHNlY29uZCBpcyBub3Qgc2V0LCBpdCBpcyBtYXBwZWQgdG8gYG51bGxgXG4gIGNvbnN0IHNpbmxnZSA9IHZhbHVlcy5sZW5ndGggPT09IDEgfHwgdmFsdWVzLnNsaWNlKCAxICkuZXZlcnkoIGlzQWJzZW50ICk7XG4gIGlmICggc2lubGdlICkge1xuICAgIHJldHVybiBbIHZhbHVlc1sgMCBdIF07XG4gIH1cblxuICByZXR1cm4gWyB2YWx1ZXNbIDEgXSwgdmFsdWVzWyAwIF0sIC4uLnZhbHVlcy5zbGljZSggMiwgbGltaXQgKSBdO1xufTtcblxuY29uc3Qgb3JkZXJSb2xsQXJndW1lbnRzID0gb3JkZXJBcmd1bWVudHMoIDMgKTtcbmNvbnN0IG9yZGVyV29kUm9sbEFyZ3VtZW50cyA9IG9yZGVyQXJndW1lbnRzKCA1ICk7XG5cbi8vIG1hcFRvUm9sbCA6OiBPYmplY3QgLT4gW09iamVjdCB8IG51bGxdXG4vLyAgIE9yZGVycyBtYXAoKSB2YWx1ZXMgd2l0aCBvcmRlckFyZ3VtZW50cygpLCB0YWtlcyB0aGUgcmVzdWx0XG4vLyAgIGFuZCByZXR1cm5zIGEgUm9sbCBvYmplY3Qgb3IgbnVsbFxuY29uc3QgbWFwVG9Sb2xsID0gKCByZXN1bHQgKSA9PiB7XG4gIGNvbnN0IHZhbHVlcyA9IG9yZGVyUm9sbEFyZ3VtZW50cyggbWFwKCByZXN1bHQgKSk7XG4gIHJldHVybiB2YWx1ZXMgPyBuZXcgUm9sbCggLi4udmFsdWVzICkgOiBudWxsO1xufTtcblxuLy8gbWFwVG9Xb2RSb2xsIDo6IE9iamVjdCAtPiBbT2JqZWN0IHwgbnVsbF1cbi8vICAgT3JkZXJzIG1hcCgpIHZhbHVlcyB3aXRoIG9yZGVyQXJndW1lbnRzKCksIHRha2VzIHRoZSByZXN1bHRcbi8vICAgYW5kIHJldHVybnMgYSBXb2RSb2xsIG9iamVjdCBvciBudWxsXG5jb25zdCBtYXBUb1dvZFJvbGwgPSAoIHJlc3VsdCApID0+IHtcbiAgY29uc3QgdmFsdWVzID0gb3JkZXJXb2RSb2xsQXJndW1lbnRzKCBtYXAoIHJlc3VsdCApKTtcbiAgcmV0dXJuIHZhbHVlcyA/IG5ldyBXb2RSb2xsKCAuLi52YWx1ZXMgKSA6IG51bGw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbWFwLFxuICBvcmRlckFyZ3VtZW50cyxcbiAgbWFwVG9Sb2xsLFxuICBtYXBUb1dvZFJvbGwsXG59O1xuIiwiLy8gaXNQb3NpdGl2ZUludGVnZXIgOjogTnVtYmVyIC0+IEJvb2xlYW5cbmNvbnN0IGlzUG9zaXRpdmVJbnRlZ2VyID0gdmFsdWUgPT4gTnVtYmVyLmlzSW50ZWdlciggdmFsdWUgKSAmJiB2YWx1ZSA+IDA7XG5cbi8vIGZpeEludmFsaWQgOjogTnVtYmVyIC0+IEFueSAtPiBOdW1iZXJcbmNvbnN0IGZpeEludmFsaWQgPSBiYWNrdXAgPT4gdmFsdWUgPT4gKCBpc1Bvc2l0aXZlSW50ZWdlciggdmFsdWUgKSA/IHZhbHVlIDogYmFja3VwICk7XG5cbi8vIG5vcm1hbGl6ZUludGVnZXIgOjogQW55IC0+IE51bWJlclxuY29uc3Qgbm9ybWFsaXplSW50ZWdlciA9IHZhbHVlID0+ICggTnVtYmVyLmlzSW50ZWdlciggdmFsdWUgKSA/IHZhbHVlIDogMCApO1xuXG4vLyBub3JtYWxpemVSb2xsUmVzdWx0IDo6IEFueSAtPiBOdW1iZXJcbmNvbnN0IG5vcm1hbGl6ZVJvbGxSZXN1bHQgPSBmaXhJbnZhbGlkKCAxICk7XG5cbi8vIG5vcm1hbGl6ZVRvcCA6OiBOdW1iZXIgLT4gTnVtYmVyIC0+IE51bWJlclxuY29uc3Qgbm9ybWFsaXplVG9wID0gbWF4ID0+IHRvcCA9PiBNYXRoLm1pbiggZml4SW52YWxpZCggTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgKSggdG9wICksIG1heCApO1xuLy8gbm9ybWFsaXplVG9wIDo6IE51bWJlciAtPiBOdW1iZXIgLT4gTnVtYmVyXG5jb25zdCBub3JtYWxpemVCb3R0b20gPSBtYXggPT4gYm90dG9tID0+IE1hdGgubWluKCBmaXhJbnZhbGlkKCAwICkoIGJvdHRvbSApLCBtYXggKTtcblxuLy8gbm9ybWFsaXplV29kQm9yZGVycyA6OiAoIE51bWJlciwgTnVtYmVyLCBOdW1iZXIgKSAtPiBbIE51bWJlciwgTnVtYmVyIF1cbmNvbnN0IG5vcm1hbGl6ZVdvZEJvcmRlcnMgPSAoIGJvdHRvbSwgdG9wLCBtYXggKSA9PiB7XG4gIGNvbnN0IGIgPSBub3JtYWxpemVUb3AoIG1heCApKCB0b3AgKTtcbiAgY29uc3QgYSA9IG5vcm1hbGl6ZUJvdHRvbSggYiAtIDEgKSggYm90dG9tICk7XG4gIHJldHVybiBbIGEsIGIgXTtcbn07XG5cbi8vIGlzRGVmaW5lZCA6OiBBbnkgLT4gQm9vbGVhblxuLy8gICBDaGVja3MgZm9yIHRoZSBleGlzdGVuY2Ugb2YgdGhlIHZhbHVlXG5jb25zdCBpc0RlZmluZWQgPSB2YWx1ZSA9PiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsO1xuXG4vLyBpc0Fic2VudCA6OiBBbnkgLT4gQm9vbGVhblxuLy8gICBDaGVja3MgZm9yIGFic2VuY2Ugb2YgdGhlIHZhbHVlcyBmcm9tIFJlZ0V4cCBleGVjdXRpb24gcmVzdWx0LlxuY29uc3QgaXNBYnNlbnQgPSB2YWx1ZSA9PiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSAnJztcblxuLy8gdG9JbnRlZ2VyIDo6IGEgLT4gTnVtYmVyIHwgYVxuLy8gYSA9IFN0cmluZyB8IEFueVxuY29uc3QgdG9JbnRlZ2VyID0gdmFsdWUgPT4gcGFyc2VJbnQoIHZhbHVlLCAxMCApIHx8IHZhbHVlO1xuXG5cbi8vIG5vcm1hbGl6ZVJlZ2V4UmVzdWx0IDo6IEFueSAtPiBudWxsIHwgTnVtYmVyIHwgU3RyaW5nXG5jb25zdCBub3JtYWxpemVSZWdleFJlc3VsdCA9IHZhbHVlID0+ICggaXNBYnNlbnQoIHZhbHVlICkgPyBudWxsIDogdG9JbnRlZ2VyKCB2YWx1ZSApKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzQWJzZW50LFxuICBpc0RlZmluZWQsXG4gIGZpeEludmFsaWQsXG4gIG5vcm1hbGl6ZUludGVnZXIsXG4gIG5vcm1hbGl6ZVJvbGxSZXN1bHQsXG4gIG5vcm1hbGl6ZVRvcCxcbiAgbm9ybWFsaXplQm90dG9tLFxuICBub3JtYWxpemVXb2RCb3JkZXJzLFxuICBub3JtYWxpemVSZWdleFJlc3VsdCxcbn07XG4iLCJjb25zdCB7IHJlc3VsdE5vdGF0aW9uIH0gPSByZXF1aXJlKCAnLi4vc3RyaW5naWZpZXInICk7XG4vKipcbiAqIEEgY2xhc3MgdGhhdCByZXByZXNlbnRzIGEgZGljZSByb2xsIHJlc3VsdFxuICogQGNsYXNzXG4gKiBAY2xhc3NkZXNjIEEgY2xhc3MgdGhhdCByZXByZXNlbnRzIGEgZGljZSByb2xsIHJlc3VsdFxuICogQHNpbmNlIHYyLjAuMFxuICogQHBhcmFtIHtTdHJpbmd9IG5vdGF0aW9uIC0gQSByb2xsIG5vdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBBIG51bWVyaWMgcmVwcmVzZW50YXRpb24gb2Ygcm9sbCByZXN1bHQsIGxpa2UgdG90YWwgc3VtbSBvciBzdWNjZXNzIGNvdW50XG4gKiBAcGFyYW0ge0FycmF5fSByb2xscyAtIEFuIGFycmF5IG9mIHJvbGxzIGRvbWVcbiAqIEBzZWUgUm9sbFxuICogQHNlZSBXb2RSb2xsXG4gKi9cbmZ1bmN0aW9uIFJlc3VsdCggbm90YXRpb24sIHZhbHVlLCByb2xscyApIHtcbiAgdGhpcy5ub3RhdGlvbiA9IG5vdGF0aW9uO1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMucm9sbHMgPSByb2xscztcbn1cblxuUmVzdWx0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gcmVzdWx0Tm90YXRpb24oIHRoaXMgKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVzdWx0O1xuIiwiY29uc3QgeyBmaXhJbnZhbGlkLCBub3JtYWxpemVJbnRlZ2VyIH0gPSByZXF1aXJlKCAnLi4vbm9ybWFsaXplcicgKTtcbmNvbnN0IHsgY2xhc3NpY05vdGF0aW9uIH0gPSByZXF1aXJlKCAnLi4vc3RyaW5naWZpZXInICk7XG5cbmNvbnN0IHBvc2l0aXZlSW50ZWdlciA9IGZpeEludmFsaWQoIDEgKTtcblxuLyoqXG4gKiBBIGNsYXNzIHRoYXQgcmVwcmVzZW50cyBhIGRpY2Ugcm9sbCBmcm9tIEQmRCBzZXR0aW5nXG4gKiBAY2xhc3NcbiAqIEBjbGFzc2Rlc2MgQSBjbGFzcyB0aGF0IHJlcHJlc2VudHMgYSBkaWNlIHJvbGwgZnJvbSBEJkQgc2V0dGluZ1xuICogQHNpbmNlIHYyLjAuMFxuICogQHBhcmFtIHtOdW1iZXJ9IGRpY2UgLSBBIG51bWJlciBvZiBkaWNlIGZhY2VzXG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgLSBBIG51bWJlciBvZiBkaWNlc1xuICogQHBhcmFtIHtOdW1iZXJ9IG1vZGlmaWVyIC0gQSBtb2RpZmllciwgdGhhdCBzaG91bGQgYmUgYWRkZWQvc3VzdHJhY3RlZCBmcm9tIHJlc3VsdFxuICogQHNlZSBXb2RSb2xsXG4gKi9cbmZ1bmN0aW9uIFJvbGwoIGRpY2UgPSAyMCwgY291bnQgPSAxLCBtb2RpZmllciA9IDAgKSB7XG4gIHRoaXMuZGljZSA9IHBvc2l0aXZlSW50ZWdlciggZGljZSApO1xuICB0aGlzLmNvdW50ID0gcG9zaXRpdmVJbnRlZ2VyKCBjb3VudCApO1xuICB0aGlzLm1vZGlmaWVyID0gbm9ybWFsaXplSW50ZWdlciggbW9kaWZpZXIgKTtcbn1cblxuUm9sbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIGNsYXNzaWNOb3RhdGlvbiggdGhpcyApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSb2xsO1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNpbXBsZTogJ3NpbXBsZScsXG4gIGNsYXNzaWM6ICdjbGFzc2ljJyxcbiAgd29kOiAnd29kJyxcbn07XG4iLCJjb25zdCB7IGZpeEludmFsaWQsIG5vcm1hbGl6ZVdvZEJvcmRlcnMgfSA9IHJlcXVpcmUoICcuLi9ub3JtYWxpemVyJyApO1xuY29uc3QgeyB3b2ROb3RhdGlvbiB9ID0gcmVxdWlyZSggJy4uL3N0cmluZ2lmaWVyJyApO1xuXG5jb25zdCBwb3NpdGl2ZUludGVnZXIgPSBmaXhJbnZhbGlkKCAxICk7XG5cbi8qKlxuICogQSBjbGFzcyB0aGF0IHJlcHJlc2VudHMgYSBkaWNlIHJvbGwgZnJvbSBXb3JsZCBvZiBEYXJrbmVzcyBzZXR0aW5nXG4gKiBAY2xhc3NcbiAqIEBjbGFzc2Rlc2MgQSBjbGFzcyB0aGF0IHJlcHJlc2VudHMgYSBkaWNlIHJvbGwgZnJvbSBXb3JsZCBvZiBEYXJrbmVzcyBzZXR0aW5nXG4gKiBAc2luY2UgdjIuMC4wXG4gKiBAcGFyYW0ge051bWJlcn0gZGljZSAtIEEgbnVtYmVyIG9mIGRpY2UgZmFjZXNcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCAtIEEgbnVtYmVyIG9mIGRpY2VzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGFnYWluIC0gQSBmbGFnIGZvciBcIjEwIEFnYWluXCIgcm9sbHMgcG9saWN5XG4gKiBAcGFyYW0ge051bWJlcn0gc3VjY2VzcyAtIEEgbWluaW11bSB2YWx1ZSwgdGhhdCBjb3VudHMgYXMgc3VjY2Vzc1xuICogQHBhcmFtIHtOdW1iZXJ9IGZhaWwgLSBBIG1heGltdW0gdmFsdWUsIHRoYXQgY291bnRzIGFzIGZhaWx1cmVcbiAqIEBzZWUgUm9sbFxuICovXG5mdW5jdGlvbiBXb2RSb2xsKCBkaWNlID0gMTAsIGNvdW50ID0gMSwgYWdhaW4gPSBmYWxzZSwgc3VjY2VzcyA9IDYsIGZhaWwgKSB7XG4gIHRoaXMuZGljZSA9IHBvc2l0aXZlSW50ZWdlciggZGljZSApO1xuICB0aGlzLmNvdW50ID0gcG9zaXRpdmVJbnRlZ2VyKCBjb3VudCApO1xuICB0aGlzLmFnYWluID0gISFhZ2FpbjtcbiAgWyB0aGlzLmZhaWwsIHRoaXMuc3VjY2VzcyBdID0gbm9ybWFsaXplV29kQm9yZGVycyggZmFpbCwgc3VjY2VzcywgdGhpcy5kaWNlICk7XG59XG5cbldvZFJvbGwucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiB3b2ROb3RhdGlvbiggdGhpcyApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBXb2RSb2xsO1xuIiwiY29uc3QgZ3JhbW1hciA9IHJlcXVpcmUoICcuL2dyYW1tYXInICk7XG5jb25zdCBUeXBlID0gcmVxdWlyZSggJy4vb2JqZWN0L1R5cGUnICk7XG5cbi8vIGlzVW5hcnkgOjogQXJyYXkgLT4gQm9vbGVhblxuY29uc3QgaXNVbmFyeSA9IGFycmF5ID0+IGFycmF5Lmxlbmd0aCA9PT0gMTtcblxuLy8gbWFrZVBhcnNlciA6OiAoIFsgUmVnRXhwIF0sIFN0cmluZyApIC0+ICggU3RyaW5nIC0+IFsgU3RyaW5nIHwgVW5kZWZpbmVkIF0gKVxuY29uc3QgbWFrZVBhcnNlciA9ICggZ3JhbW1hclNldCwgdHlwZSApID0+IHtcbiAgaWYgKCBpc1VuYXJ5KCBncmFtbWFyU2V0ICkpIHtcbiAgICByZXR1cm4gKCByb2xsICkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZ3JhbW1hclNldFsgMCBdLmV4ZWMoIHJvbGwgKTtcbiAgICAgIGlmICggcmVzdWx0ICkge1xuICAgICAgICByZXN1bHQudHlwZSA9IHR5cGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH1cbiAgcmV0dXJuICggcm9sbCApID0+IHtcbiAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICBncmFtbWFyU2V0LnNvbWUoIHJlZ2V4ID0+ICggcmVzdWx0ID0gcmVnZXguZXhlYyggcm9sbCApKSk7XG4gICAgaWYgKCByZXN1bHQgKSB7XG4gICAgICByZXN1bHQudHlwZSA9IHR5cGU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59O1xuXG4vLyBwYXJzZVNpbXBsZSA6OiBTdHJpbmcgLT4gWyBTdHJpbmcgfCBVbmRlZmluZWQgXVxuY29uc3QgcGFyc2VTaW1wbGUgPSBtYWtlUGFyc2VyKCBncmFtbWFyLnNpbXBsZSwgVHlwZS5zaW1wbGUgKTtcbi8vIHBhcnNlQ2xhc3NpYyA6OiBTdHJpbmcgLT4gWyBTdHJpbmcgfCBVbmRlZmluZWQgXVxuY29uc3QgcGFyc2VDbGFzc2ljID0gbWFrZVBhcnNlciggZ3JhbW1hci5jbGFzc2ljLCBUeXBlLmNsYXNzaWMgKTtcbi8vIHBhcnNlV29kIDo6IFN0cmluZyAtPiBbIFN0cmluZyB8IFVuZGVmaW5lZCBdXG5jb25zdCBwYXJzZVdvZCA9IG1ha2VQYXJzZXIoIGdyYW1tYXIud29kLCBUeXBlLndvZCApO1xuLy8gcGFyc2VBbnkgOjogU3RyaW5nIC0+IFsgU3RyaW5nIHwgVW5kZWZpbmVkIF1cbmNvbnN0IHBhcnNlQW55ID0gcm9sbCA9PiBwYXJzZUNsYXNzaWMoIHJvbGwgKSB8fCBwYXJzZVNpbXBsZSggcm9sbCApIHx8IHBhcnNlV29kKCByb2xsICk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBtYWtlUGFyc2VyLFxuICBwYXJzZVNpbXBsZSxcbiAgcGFyc2VDbGFzc2ljLFxuICBwYXJzZVdvZCxcbiAgcGFyc2VBbnksXG59O1xuIiwiLy8gcmFuZG9tIDo6IE51bWJlciAtPiBOdW1iZXIgLT4gTnVtYmVyXG4vLyAgIEdlbmVyYXRlcyByYW5kb20gaW50ZWdlciBmcm9tIHRoZSByYW5nZSBvZiBbIG1pbiwgbWF4IF0gdmFsdWVzXG5jb25zdCByYW5kb20gPSBtaW4gPT4gbWF4ID0+IE1hdGguZmxvb3IoIE1hdGgucmFuZG9tKCkgKiAoKCBtYXggKyAxICkgLSBtaW4gKSkgKyBtaW47XG5cbi8qKlxuICogR2VuZXJhdGVzIHJhbmRvbSBwb3NpdGl2ZSBpbnRlZ2VyIGZyb20gYDFgIHRvIGBtYXhgLlxuICpcbiAqIEBmdW5jXG4gKiBAYWxpYXMgcmFuZG9tXG4gKiBAc2luY2UgdjIuMC4wXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4IC0gbWF4aW11bSBwb3NzaWJsZSBnZW5lcmF0ZWQgdmFsdWVcbiAqIEByZXR1cm4ge051bWJlcn0gUG9zaXRpdmUgaW50ZWdlciwgZnJvbSBgMWAgdG8gYG1heGBcbiAqIEBleGFtcGxlXG4gKiByYW5kb20oMTAwKTsgLy89PiA3NyAtIHJhbmRvbSBudW1iZXIgZnJvbSAxIHRvIDEwMFxuICogcmFuZG9tKDEpOyAgIC8vPT4gIDEgLSBhbHdheXMgcm9sbHMgMVxuICovXG5jb25zdCByYW5kb21Sb2xsID0gcmFuZG9tKCAxICk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICByYW5kb20sXG4gIHJhbmRvbVJvbGwsXG59O1xuIiwiY29uc3QgeyByYW5kb21Sb2xsIH0gPSByZXF1aXJlKCAnLi9yYW5kb20nICk7XG5jb25zdCB7IG5vcm1hbGl6ZVJvbGxSZXN1bHQsIGlzRGVmaW5lZCB9ID0gcmVxdWlyZSggJy4vbm9ybWFsaXplcicgKTtcbmNvbnN0IHsgY29udmVydFRvUm9sbCwgY29udmVydFRvV29kUm9sbCwgY29udmVydFRvQW55Um9sbCB9ID0gcmVxdWlyZSggJy4vY29udmVydGVyJyApO1xuY29uc3QgUmVzdWx0ID0gcmVxdWlyZSggJy4vb2JqZWN0L1Jlc3VsdCcgKTtcbmNvbnN0IFJvbGwgPSByZXF1aXJlKCAnLi9vYmplY3QvUm9sbCcgKTtcbmNvbnN0IFdvZFJvbGwgPSByZXF1aXJlKCAnLi9vYmplY3QvV29kUm9sbCcgKTtcblxuXG4vKipcbiAqIFJvbGxzIHRoZSBkaWNlIGZyb20gYFJvbGxgIG9iamVjdC5cbiAqXG4gKiBAZnVuY1xuICogQHNpbmNlIHYyLjAuMFxuICogQHBhcmFtIHtSb2xsfSByb2xsIC0gYFJvbGxgIG9iamVjdCBvciBzaW1pbGFyXG4gKiBAcmV0dXJuIHtSZXN1bHR9XG4gKiBAc2VlIHJvbGxcbiAqIEBzZWUgcm9sbFdvZFxuICogQGV4YW1wbGVcbiAqIHJvbGxDbGFzc2ljKG5ldyBSb2xsKDEwLCAyLCAtMSkpOyAvLz0+IHsgbm90YXRpb246ICcyZDEwLTEnLCB2YWx1ZTogMTQsIHJvbGxzOiBbIDcsIDggXSB9XG4gKiByb2xsQ2xhc3NpYyh7IGRpY2U6IDYgfSk7IC8vPT4geyBub3RhdGlvbjogJ2Q2JywgdmFsdWU6IDQsIHJvbGxzOiBbIDQgXSB9XG4gKi9cbmZ1bmN0aW9uIHJvbGxDbGFzc2ljKCByb2xsICkge1xuICBjb25zdCBkYXRhID0gcm9sbCBpbnN0YW5jZW9mIFJvbGwgPyByb2xsIDogY29udmVydFRvUm9sbCggcm9sbCApO1xuICBjb25zdCB7IGRpY2UsIGNvdW50LCBtb2RpZmllciB9ID0gZGF0YTtcblxuICBjb25zdCByb2xscyA9IFsgLi4ubmV3IEFycmF5KCBjb3VudCApIF0ubWFwKCgpID0+IHJhbmRvbVJvbGwoIGRpY2UgKSk7XG4gIGNvbnN0IHN1bW0gPSByb2xscy5yZWR1Y2UoKCBwcmV2LCBjdXJyICkgPT4gcHJldiArIGN1cnIsIDAgKTtcbiAgY29uc3QgcmVzdWx0ID0gbm9ybWFsaXplUm9sbFJlc3VsdCggc3VtbSArIG1vZGlmaWVyICk7XG5cbiAgcmV0dXJuIG5ldyBSZXN1bHQoIGRhdGEudG9TdHJpbmcoKSwgcmVzdWx0LCByb2xscyApO1xufVxuXG4vKipcbiAqIFJvbGxzIHRoZSBkaWNlIGZyb20gYFdvZFJvbGxgIG9iamVjdC5cbiAqXG4gKiBAZnVuY1xuICogQHNpbmNlIHYyLjAuMFxuICogQHBhcmFtIHtXb2RSb2xsfSByb2xsIC0gYFdvZFJvbGxgIG9iamVjdCBvciBzaW1pbGFyXG4gKiBAcmV0dXJuIHtSZXN1bHR9XG4gKiBAc2VlIHJvbGxcbiAqIEBzZWUgcm9sbENsYXNzaWNcbiAqIEBleGFtcGxlXG4gKiByb2xsV29kKG5ldyBXb2RSb2xsKDEwLCA0LCB0cnVlLCA4KSk7IC8vPT4geyBub3RhdGlvbjogJzRkMTAhPjgnLCB2YWx1ZTogMiwgcm9sbHM6IFszLDEwLDcsOSw1XSB9XG4gKiByb2xsV29kKHsgZGljZTogOCwgY291bnQ6IDMgfSk7IC8vPT4geyBub3RhdGlvbjogJzNkOD42JywgdmFsdWU6IDIsIHJvbGxzOiBbIDcsIDMsIDkgXSB9XG4gKi9cbmZ1bmN0aW9uIHJvbGxXb2QoIHJvbGwgKSB7XG4gIGNvbnN0IGRhdGEgPSByb2xsIGluc3RhbmNlb2YgV29kUm9sbCA/IHJvbGwgOiBjb252ZXJ0VG9Xb2RSb2xsKCByb2xsICk7XG4gIGNvbnN0IHsgZGljZSwgY291bnQsIGFnYWluLCBzdWNjZXNzLCBmYWlsIH0gPSBkYXRhO1xuXG4gIGNvbnN0IHJvbGxzID0gW107XG5cbiAgbGV0IGkgPSBjb3VudDtcbiAgd2hpbGUgKCBpID4gMCApIHtcbiAgICBjb25zdCB2YWx1ZSA9IHJhbmRvbVJvbGwoIGRpY2UgKTtcbiAgICByb2xscy5wdXNoKCB2YWx1ZSApO1xuICAgIC8vIENoZWNrIGZvciBcIjEwIEFnYWluXCIgZmxhZ1xuICAgIC8vIGByZXBlYXRMaW1pdGAgd2lsbCBwcmV2ZW50IGluZmluaXRlIGxvb3AsIGZvciBjYXNlcyBsaWtlIGBkMSE+MWBcbiAgICBjb25zdCByZXBlYXRMaW1pdCA9IDEwMDtcbiAgICBpZiAoIHZhbHVlICE9PSBkaWNlIHx8ICFhZ2FpbiB8fCByb2xscy5sZW5ndGggPiByZXBlYXRMaW1pdCApIHtcbiAgICAgIGkgLT0gMTtcbiAgICB9XG4gIH1cblxuICBjb25zdCByZXN1bHQgPSByb2xscy5yZWR1Y2UoKCBzdWMsIHZhbCApID0+IHtcbiAgICBpZiAoIHZhbCA+PSBzdWNjZXNzICkge1xuICAgICAgcmV0dXJuIHN1YyArIDE7XG4gICAgfSBlbHNlIGlmICggdmFsIDw9IGZhaWwgKSB7XG4gICAgICByZXR1cm4gc3VjIC0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHN1YztcbiAgfSwgMCApO1xuXG4gIHJldHVybiBuZXcgUmVzdWx0KCBkYXRhLnRvU3RyaW5nKCksIE1hdGgubWF4KCByZXN1bHQsIDAgKSwgcm9sbHMgKTtcbn1cblxuLyoqXG4gKiBSb2xscyB0aGUgZGljZSBmcm9tIGBSb2xsYCBvciBgV29kUm9sbGAgb2JqZWN0cy5cbiAqXG4gKiBAZnVuY1xuICogQGFsaWFzIHJvbGxcbiAqIEBzaW5jZSB2Mi4wLjBcbiAqIEBwYXJhbSB7Um9sbHxXb2RSb2xsfE9iamVjdH0gcm9sbCAtIGBSb2xsYCwgYFdvZFJvbGxgIG9yIHNpbWlsYXIgb2JqZWN0LlxuICogQHJldHVybiB7UmVzdWx0fSBSZXR1cm5zIGBSZXN1bHRgIGZvciBkZWZpbmVkIHBhcmFtZXRlcnMsIG90aGVyd2lzZSByZXR1cm5zIGBudWxsYC5cbiAqIEBzZWUgcm9sbENsYXNzaWNcbiAqIEBzZWUgcm9sbFdvZFxuICogQGV4YW1wbGVcbiAqIHJvbGwobmV3IFJvbGwoMTAsIDIsIC0xKSk7IC8vPT4geyBub3RhdGlvbjogJzJkMTAtMScsIHZhbHVlOiAxNCwgcm9sbHM6IFsgNywgOCBdIH1cbiAqIHJvbGwoeyBkaWNlOiA2IH0pOyAvLz0+IHsgbm90YXRpb246ICdkNicsIHZhbHVlOiA0LCByb2xsczogWyA0IF0gfVxuICogcm9sbChuZXcgV29kUm9sbCgxMCwgNCwgdHJ1ZSwgOCkpOyAvLz0+IHsgbm90YXRpb246ICc0ZDEwIT44JywgdmFsdWU6IDIsIHJvbGxzOiBbMywxMCw3LDksNV0gfVxuICogcm9sbCh7IGRpY2U6IDgsIGNvdW50OiAzLCBhZ2FpbjogdHJ1ZSB9KTsgLy89PiB7IG5vdGF0aW9uOiAnM2Q4IT42JywgdmFsdWU6IDIsIHJvbGxzOiBbNywzLDkgXSB9XG4gKiByb2xsKCBudWxsICk7IC8vPT4gbnVsbFxuICovXG5mdW5jdGlvbiByb2xsQW55KCByb2xsICkge1xuICBpZiAoIHJvbGwgaW5zdGFuY2VvZiBSb2xsICkge1xuICAgIHJldHVybiByb2xsQ2xhc3NpYyggcm9sbCApO1xuICB9IGVsc2UgaWYgKCByb2xsIGluc3RhbmNlb2YgV29kUm9sbCApIHtcbiAgICByZXR1cm4gcm9sbFdvZCggcm9sbCApO1xuICB9XG4gIHJldHVybiBpc0RlZmluZWQoIHJvbGwgKSA/IHJvbGxBbnkoIGNvbnZlcnRUb0FueVJvbGwoIHJvbGwgKSkgOiBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcm9sbENsYXNzaWMsXG4gIHJvbGxXb2QsXG4gIHJvbGxBbnksXG59O1xuIiwiZnVuY3Rpb24gc2ltcGxlTm90YXRpb24oIHJvbGwgKSB7XG4gIGNvbnN0IGNvdW50ID0gcm9sbC5jb3VudCA+IDEgPyBgJHsgcm9sbC5jb3VudCB9IGAgOiAnJztcbiAgY29uc3QgbW9kaWZpZXIgPSByb2xsLm1vZGlmaWVyID8gYCAkeyByb2xsLm1vZGlmaWVyIH1gIDogJyc7XG5cbiAgcmV0dXJuIGAkeyBjb3VudCB9JHsgcm9sbC5kaWNlIH0keyBtb2RpZmllciB9YDtcbn1cblxuZnVuY3Rpb24gY2xhc3NpY05vdGF0aW9uKCByb2xsICkge1xuICBjb25zdCBjb3VudCA9IHJvbGwuY291bnQgPiAxID8gcm9sbC5jb3VudCA6ICcnO1xuICBjb25zdCBtb2RpZmllciA9IHJvbGwubW9kaWZpZXIgPiAwID8gYCskeyByb2xsLm1vZGlmaWVyIH1gIDogKCByb2xsLm1vZGlmaWVyIHx8ICcnICk7XG5cbiAgcmV0dXJuIGAkeyBjb3VudCB9ZCR7IHJvbGwuZGljZSB9JHsgbW9kaWZpZXIgfWA7XG59XG5cbmZ1bmN0aW9uIHdvZE5vdGF0aW9uKCByb2xsICkge1xuICBjb25zdCBjb3VudCA9IHJvbGwuY291bnQgPiAxID8gcm9sbC5jb3VudCA6ICcnO1xuICBjb25zdCBhZ2FpbiA9IHJvbGwuYWdhaW4gPyAnIScgOiAnJztcbiAgY29uc3QgZmFpbCA9IHJvbGwuZmFpbCA+IDAgPyBgZiR7IHJvbGwuZmFpbCB9YCA6ICcnO1xuXG4gIHJldHVybiBgJHsgY291bnQgfWQkeyByb2xsLmRpY2UgfSR7IGFnYWluIH0+JHsgcm9sbC5zdWNjZXNzIH0keyBmYWlsIH1gO1xufVxuXG5mdW5jdGlvbiByZXN1bHROb3RhdGlvbiggcmVzdWx0ICkge1xuICBjb25zdCB7IG5vdGF0aW9uLCB2YWx1ZSwgcm9sbHMgfSA9IHJlc3VsdDtcbiAgcmV0dXJuIGAoJHsgbm90YXRpb24gfSkgJHsgdmFsdWUgfSBbJHsgcm9sbHMgfV1gO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2ltcGxlTm90YXRpb24sXG4gIGNsYXNzaWNOb3RhdGlvbixcbiAgd29kTm90YXRpb24sXG4gIHJlc3VsdE5vdGF0aW9uLFxufTtcbiJdfQ==
